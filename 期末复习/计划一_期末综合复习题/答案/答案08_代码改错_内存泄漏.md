# 答案08：代码改错 - 内存泄漏

## 错误分析

### 错误1：内存泄漏
- **位置**：main函数中，缺少对 `ptr2` 的释放
- **问题**：使用 `new[]` 分配的内存没有对应的 `delete[]`
- **后果**：内存泄漏，程序运行时间越长，内存占用越大

### 错误2：delete和delete[]不匹配
- **位置**：`delete ptr1;` 应该是 `delete[] ptr1;`
- **问题**：使用 `new[]` 分配数组，必须使用 `delete[]` 释放
- **后果**：可能导致未定义行为，虽然可能不会立即崩溃，但这是严重的错误

## 修正后的代码

```cpp
#include <iostream>
using namespace std;

int* createArray(int size) {
    int* arr = new int[size];
    for (int i = 0; i < size; i++) {
        arr[i] = i * 2;
    }
    return arr;
}

int main() {
    int* ptr1 = createArray(5);
    int* ptr2 = createArray(10);
    
    for (int i = 0; i < 5; i++) {
        cout << ptr1[i] << " ";
    }
    cout << endl;
    
    for (int i = 0; i < 10; i++) {
        cout << ptr2[i] << " ";
    }
    cout << endl;
    
    // 修正：使用delete[]释放数组
    delete[] ptr1;
    delete[] ptr2;  // 修正：添加对ptr2的释放
    
    return 0;
}
```

## 详细解析

### new和delete的配对规则

1. **单个对象**：
   ```cpp
   int* p = new int;      // 分配
   delete p;               // 释放
   ```

2. **数组对象**：
   ```cpp
   int* arr = new int[10]; // 分配数组
   delete[] arr;           // 释放数组（必须用delete[]）
   ```

### 为什么必须配对？

- **new/delete**：用于单个对象，会调用构造函数/析构函数
- **new[]/delete[]**：用于数组，会调用多次构造函数/析构函数
- **不匹配的后果**：
  - `new[]` 后用 `delete`：可能只释放第一个元素，导致内存泄漏
  - `new` 后用 `delete[]`：可能导致程序崩溃

### 内存泄漏的危害

1. **短期**：可能看不出问题
2. **长期**：内存占用不断增长，最终可能导致：
   - 系统变慢
   - 程序崩溃
   - 系统资源耗尽

### 最佳实践

1. **使用智能指针**（推荐）：
   ```cpp
   #include <memory>
   unique_ptr<int[]> arr(new int[10]);
   // 自动释放，无需手动delete
   ```

2. **使用vector**（更推荐）：
   ```cpp
   vector<int> arr(10);
   // 自动管理内存，无需手动释放
   ```

3. **如果必须使用new/delete**：
   - 确保每个 `new` 都有对应的 `delete`
   - 确保每个 `new[]` 都有对应的 `delete[]`
   - 在分配后立即考虑如何释放

### 常见错误总结

| 错误代码 | 正确代码 | 说明 |
|---------|---------|------|
| `delete ptr;` (ptr指向数组) | `delete[] ptr;` | 数组必须用delete[] |
| 忘记delete | 添加delete | 每个new都要有delete |
| delete后继续使用 | 置为nullptr | 避免悬空指针 |

