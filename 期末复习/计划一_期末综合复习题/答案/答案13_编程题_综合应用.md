# 答案13：编程题 - 综合应用

## 完整代码

见 `答案13_编程题_综合应用.cpp`

## 关键知识点解析

### 1. 类的设计

```cpp
class Book {
private:
    string title, author;
    double price;
public:
    Book(string t, string a, double p);
    // Getter函数
    void display() const;  // const成员函数
};
```

- **封装**：私有成员，公有接口
- **const成员函数**：不修改对象状态
- **Getter函数**：提供访问私有成员的接口

### 2. map的使用

```cpp
map<string, Book> books;
books[title] = Book(...);  // 添加/修改
auto it = books.find(title);  // 查找
books.erase(it);  // 删除
```

- **键值对**：`pair<key, value>`
- **自动排序**：map按键自动排序
- **唯一键**：每个键只能出现一次

### 3. map的查找

```cpp
auto it = books.find(title);
if (it != books.end()) {
    // 找到
    it->second.display();  // 访问值
} else {
    // 未找到
}
```

- **find()**：返回迭代器
- **it->second**：访问值（Book对象）
- **it->first**：访问键（string）

### 4. 使用max_element查找最大值

```cpp
auto max_it = max_element(books.begin(), books.end(),
    [](const pair<string, Book>& a, const pair<string, Book>& b) {
        return a.second.getPrice() < b.second.getPrice();
    });
```

- **Lambda表达式**：自定义比较函数
- **比较价格**：`a.second.getPrice() < b.second.getPrice()`
- **返回值**：指向价格最高元素的迭代器

### 5. 范围for循环遍历map

```cpp
for (const auto& pair : books) {
    pair.second.display();
}
```

- **auto**：自动推导类型
- **const auto&**：常量引用，避免拷贝
- **pair类型**：map的元素是 `pair<key, value>`

## 测试用例

### 输入
```
5
ADD 算法导论 托马斯 89.5
ADD C++程序设计 张三 65.0
ADD 数据结构 李四 78.0
FIND 算法导论
MAX
DELETE C++程序设计
```

### 输出
```
[算法导论] by 托马斯, Price: 89.50
Most expensive: [算法导论] by 托马斯, Price: 89.50
Deleted: C++程序设计

All books:
[数据结构] by 李四, Price: 78.00
[算法导论] by 托马斯, Price: 89.50
```

## 代码解析

### 添加图书
```cpp
books[title] = Book(title, author, price);
```
- 如果键不存在，自动创建
- 如果键已存在，覆盖原值

### 查找图书
```cpp
auto it = books.find(title);
if (it != books.end()) {
    it->second.display();
}
```
- `find()` 返回迭代器
- `end()` 表示未找到

### 删除图书
```cpp
books.erase(it);
```
- 使用迭代器删除
- 也可以使用 `books.erase(title)` 直接删除

### 查找价格最高
```cpp
auto max_it = max_element(books.begin(), books.end(),
    [](const pair<string, Book>& a, const pair<string, Book>& b) {
        return a.second.getPrice() < b.second.getPrice();
    });
```
- Lambda表达式比较价格
- 返回价格最高的图书

## 常见错误

1. **map迭代器类型错误**：
   ```cpp
   // 正确
   for (const auto& pair : books)
   // 错误
   for (Book book : books)  // map的元素是pair，不是Book
   ```

2. **访问map元素错误**：
   ```cpp
   // 正确
   it->second.display();
   // 错误
   it.display();  // it是迭代器，不是Book对象
   ```

3. **Lambda表达式语法错误**：
   ```cpp
   // 正确
   [](const pair<string, Book>& a, const pair<string, Book>& b) { ... }
   // 错误
   (const pair<string, Book>& a, ...) { ... }  // 缺少[]
   ```

## 扩展思考

1. 如何使用unordered_map提高查找效率？
2. 如何实现按价格排序输出？
3. 如何添加更多操作（如修改价格）？

