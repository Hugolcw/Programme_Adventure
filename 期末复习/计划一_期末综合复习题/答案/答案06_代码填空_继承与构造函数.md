# 答案06：代码填空 - 继承与构造函数

## 正确答案

```cpp
#include <iostream>
using namespace std;

class Shape {
protected:
    double x, y;  // 中心点坐标
public:
    Shape(double x, double y) : x(x), y(y) {
        cout << "Shape constructor: (" << x << ", " << y << ")" << endl;
    }
    virtual double getArea() = 0;  // 纯虚函数
};

class Rectangle : public Shape {
private:
    double width, height;
public:
    // 构造函数：使用初始化列表
    Rectangle(double x, double y, double w, double h) 
        : Shape(x, y), width(w), height(h) {
        // 基类构造函数已通过初始化列表调用
    }
    
    // 实现纯虚函数
    double getArea() override {
        return width * height;
    }
    
    void display() {
        cout << "Rectangle: center(" << x << ", " << y 
             << "), size(" << width << "x" << height 
             << "), area=" << getArea() << endl;
    }
};

int main() {
    Rectangle rect(0, 0, 5, 3);
    rect.display();
    return 0;
}
```

## 解析

### 构造函数初始化列表

```cpp
Rectangle(double x, double y, double w, double h) 
    : Shape(x, y), width(w), height(h) {
    // 函数体可以为空
}
```

**关键点**：
1. **调用基类构造函数**：`Shape(x, y)` - 必须放在最前面
2. **初始化成员变量**：`width(w), height(h)` - 按声明顺序初始化
3. **冒号语法**：使用 `:` 开始初始化列表
4. **逗号分隔**：多个初始化项用逗号分隔

### 纯虚函数实现

```cpp
double getArea() override {
    return width * height;
}
```

**关键点**：
1. **必须实现**：派生类必须实现基类的纯虚函数，否则无法实例化
2. **override关键字**：C++11引入，明确表示重写虚函数（可选但推荐）
3. **返回值类型**：必须与基类声明一致

### 程序输出

```
Shape constructor: (0, 0)
Rectangle: center(0, 0), size(5x3), area=15
```

### 常见错误

1. **忘记调用基类构造函数**：
   ```cpp
   // 错误
   Rectangle(...) : width(w), height(h) { }
   // 正确
   Rectangle(...) : Shape(x, y), width(w), height(h) { }
   ```

2. **初始化顺序错误**：应该先基类，后成员变量

3. **忘记实现纯虚函数**：会导致编译错误

### 扩展知识

- **访问控制**：`protected` 成员在派生类中可以直接访问
- **抽象类**：包含纯虚函数的类不能直接实例化
- **多态**：可以通过基类指针调用派生类的 `getArea()` 函数

