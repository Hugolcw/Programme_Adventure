# 答案01：斐波那契数列

## 完整代码

见 `答案01_基础递归_斐波那契数列.cpp`

## 解题思路

### 核心算法

这是一个经典的双递归调用问题。根据斐波那契数列的定义，第n项等于前两项之和。

### 递归三要素

1. **终止条件**：
   - n == 0：返回0
   - n == 1：返回1

2. **递归关系**：
   - F(n) = F(n-1) + F(n-2)

3. **递归调用**：
   - 调用`fib(n-1)`计算前一项
   - 调用`fib(n-2)`计算前两项
   - 将两者相加返回

### 关键代码逻辑

```cpp
long long fib(int n) {
    // 终止条件
    if (n == 0) return 0;
    if (n == 1) return 1;
    
    // 递归关系：F(n) = F(n-1) + F(n-2)
    return fib(n-1) + fib(n-2);
}
```

### 递归树示例（n=5）

```
                    fib(5)
                   /      \
              fib(4)      fib(3)
             /     \      /     \
        fib(3)  fib(2)  fib(2)  fib(1)
        /   \    /  \    /  \
   fib(2) fib(1) ...   ...  ...
   /   \
fib(1) fib(0)
```

**注意**：递归树中有很多重复计算，例如`fib(3)`被计算了多次。

### 示例演示

**n=0**：
- 直接返回0

**n=1**：
- 直接返回1

**n=2**：
- `fib(2) = fib(1) + fib(0) = 1 + 0 = 1`

**n=3**：
- `fib(3) = fib(2) + fib(1) = 1 + 1 = 2`

**n=5**：
- `fib(5) = fib(4) + fib(3)`
- `fib(4) = fib(3) + fib(2) = 2 + 1 = 3`
- `fib(3) = fib(2) + fib(1) = 1 + 1 = 2`
- `fib(5) = 3 + 2 = 5`

## 测试用例

### 测试用例1

**输入**：
```
0
```

**输出**：
```
0
```

### 测试用例2

**输入**：
```
1
```

**输出**：
```
1
```

### 测试用例3

**输入**：
```
5
```

**输出**：
```
5
```

### 测试用例4

**输入**：
```
10
```

**输出**：
```
55
```

## 常见错误

1. **终止条件错误**：忘记处理n=0的情况
2. **递归关系错误**：应该是`fib(n-1) + fib(n-2)`，不是`fib(n) + fib(n-1)`
3. **数据类型错误**：n较大时结果可能超过int范围，应使用`long long`
4. **缺少终止条件**：如果没有终止条件，会导致无限递归

## 算法复杂度

- **时间复杂度**：O(2^n)，因为每个节点都会展开成两个子节点
- **空间复杂度**：O(n)，递归栈的深度为n

## 扩展思考

1. **如何优化递归**？使用记忆化（memoization）存储已计算的结果
2. **如何用迭代实现**？使用循环代替递归，时间复杂度O(n)
3. **如何计算大n的值**？需要高精度计算或矩阵快速幂

