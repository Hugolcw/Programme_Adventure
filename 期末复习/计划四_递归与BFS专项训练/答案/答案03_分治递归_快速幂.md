# 答案03：快速幂

## 完整代码

见 `答案03_分治递归_快速幂.cpp`

## 解题思路

### 核心算法

快速幂是典型的分治递归算法。通过将指数分成两半，可以将时间复杂度从O(n)降低到O(log n)。

### 快速幂思想

- **如果n是偶数**：a^n = (a^(n/2))²
- **如果n是奇数**：a^n = a × a^(n-1) = a × (a^((n-1)/2))²

这样每次递归都将指数减半，总递归深度为log n。

### 递归三要素

1. **终止条件**：
   - n == 0：返回1（任何数的0次幂都是1）

2. **递归关系**：
   - n是偶数：`power(a, n) = power(a, n/2)²`
   - n是奇数：`power(a, n) = a × power(a, (n-1)/2)²`

3. **递归调用**：调用自身计算较小的幂

### 关键代码逻辑

```cpp
const long long MOD = 1000000007;

long long power(long long a, long long n) {
    // 终止条件
    if (n == 0) {
        return 1;
    }
    
    // 递归关系：计算a^(n/2)
    long long half = power(a, n / 2);
    
    if (n % 2 == 0) {
        // n是偶数：a^n = (a^(n/2))^2
        return (half * half) % MOD;
    } else {
        // n是奇数：a^n = a × (a^(n/2))^2
        return (a * half * half) % MOD;
    }
}
```

### 示例演示

**示例1**：计算2^10

```
power(2, 10)
  n=10是偶数
  half = power(2, 5)
    n=5是奇数
    half = power(2, 2)
      n=2是偶数
      half = power(2, 1)
        n=1是奇数
        half = power(2, 0) = 1
        return 2 × 1 × 1 = 2
      return 2 × 2 = 4
    return 2 × 4 × 4 = 32
  return 32 × 32 = 1024
```

**递归调用过程**：
- power(2, 10) → power(2, 5) → power(2, 2) → power(2, 1) → power(2, 0)
- power(2, 0) = 1
- power(2, 1) = 2 × 1² = 2
- power(2, 2) = 2² = 4
- power(2, 5) = 2 × 4² = 32
- power(2, 10) = 32² = 1024

### 递归树示例（2^10）

```
          power(2, 10)
              |
         power(2, 5)
              |
         power(2, 2)
              |
         power(2, 1)
              |
         power(2, 0) = 1
```

## 测试用例

### 测试用例1

**输入**：
```
2 10
```

**输出**：
```
1024
```

### 测试用例2

**输入**：
```
3 5
```

**输出**：
```
243
```

## 常见错误

1. **模运算错误**：每一步都要取模，防止溢出
2. **递归关系错误**：注意奇偶性的处理
3. **终止条件错误**：n=0时应该返回1，不是0
4. **数据类型错误**：应使用`long long`，防止溢出

## 算法复杂度

- **时间复杂度**：O(log n)，每次递归指数减半
- **空间复杂度**：O(log n)，递归栈的深度为log n

## 扩展思考

1. **如何用迭代实现**？使用循环代替递归
2. **如何计算a^n mod m（m是任意数）**？修改MOD常量
3. **如何优化空间**？使用迭代版本，空间复杂度O(1)

