# 答案04：全排列

## 完整代码

见 `答案04_回溯递归_全排列.cpp`

## 解题思路

### 核心算法

全排列是典型的回溯递归问题。通过尝试在每个位置放置不同的数字，并使用回溯来生成所有可能的排列。

### 回溯思想

1. **尝试**：在当前位置尝试放置一个未使用的数字
2. **递归**：放置后，递归处理下一个位置
3. **回溯**：递归返回后，恢复状态（标记数字为未使用），尝试下一个数字

### 递归三要素

1. **终止条件**：
   - `pos == n`：已经放置了n个数字，输出当前排列

2. **递归关系**：
   - 对于当前位置`pos`，尝试放置所有未使用的数字
   - 放置数字i后，标记为已使用，递归处理`pos+1`
   - 递归返回后，标记为未使用（回溯），尝试下一个数字

3. **递归调用**：调用自身处理下一个位置

### 关键代码逻辑

```cpp
int arr[10];      // 存储当前排列
bool used[10];    // 标记数字是否已使用

void permute(int pos, int n) {
    // 终止条件：已经放置了n个数字
    if (pos == n) {
        // 输出当前排列
        for (int i = 0; i < n; i++) {
            if (i > 0) cout << " ";
            cout << arr[i];
        }
        cout << endl;
        return;
    }
    
    // 递归关系：尝试放置所有未使用的数字
    for (int i = 1; i <= n; i++) {
        if (!used[i]) {
            // 尝试：放置数字i
            arr[pos] = i;
            used[i] = true;
            
            // 递归：处理下一个位置
            permute(pos + 1, n);
            
            // 回溯：恢复状态
            used[i] = false;
        }
    }
}
```

### 示例演示（n=3）

**递归过程**：
```
permute(0, 3)
  pos=0，尝试放置1
    arr[0]=1, used[1]=true
    permute(1, 3)
      pos=1，尝试放置2
        arr[1]=2, used[2]=true
        permute(2, 3)
          pos=2，尝试放置3
            arr[2]=3, used[3]=true
            permute(3, 3) → 输出[1,2,3]
            used[3]=false（回溯）
          used[2]=false（回溯）
      pos=1，尝试放置3
        arr[1]=3, used[3]=true
        permute(2, 3)
          pos=2，尝试放置2
            arr[2]=2, used[2]=true
            permute(3, 3) → 输出[1,3,2]
            ...
    used[1]=false（回溯）
  pos=0，尝试放置2
    ...
  pos=0，尝试放置3
    ...
```

### 递归树示例（n=2）

```
            permute(0, 2)
           /      |      \
        1/        |2       \3（不存在）
         |        |
    permute(1, 2) permute(1, 2)
     /    \       /    \
   2/      \3   1/      \3
   |        |   |        |
输出[1,2]  (跳过) 输出[2,1]  (跳过)
```

## 测试用例

### 测试用例1

**输入**：
```
3
```

**输出**：
```
1 2 3
1 3 2
2 1 3
2 3 1
3 1 2
3 2 1
```

### 测试用例2

**输入**：
```
2
```

**输出**：
```
1 2
2 1
```

## 常见错误

1. **忘记回溯**：递归返回后必须恢复状态，否则会漏掉排列
2. **状态标记错误**：`used`数组的初始化应为`false`
3. **输出格式错误**：注意空格的处理
4. **边界处理错误**：`pos`从0开始，终止条件是`pos == n`

## 算法复杂度

- **时间复杂度**：O(n × n!)，共有n!个排列，每个排列需要O(n)时间输出
- **空间复杂度**：O(n)，递归栈深度为n，加上数组空间

## 扩展思考

1. **如何生成有重复元素的全排列**？需要去重处理
2. **如何生成组合**？修改递归条件，只考虑顺序
3. **如何优化输出**？可以使用更高效的数据结构

