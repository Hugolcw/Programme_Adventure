# 答案08：最短路径长度

## 完整代码

见 `答案08_基础BFS_最短路径长度.cpp`

## 解题思路

### 核心算法

使用BFS算法计算无权图的最短路径长度。BFS的层次遍历特性保证了第一次到达终点时的路径就是最短路径。

### BFS算法

1. **初始化**：
   - 队列：存储待访问节点
   - 访问标记：`visited[i]`标记节点i是否已访问
   - 距离数组：`dist[i]`记录节点i到起点的距离

2. **BFS主循环**：
   - 将起点入队，标记为已访问，距离为0
   - 当队列非空时：
     - 取出队首节点
     - 如果找到终点，返回距离
     - 遍历所有邻居，如果未访问，入队并更新距离

### 关键代码逻辑

```cpp
int bfs(int a[][N], int n, int start, int end) {
    int q[N * N];              // 队列（数组模拟）
    int visited[N] = {0};      // 访问标记
    int dist[N] = {0};         // 距离数组
    int head = 0, tail = 0;    // 队列头尾指针

    // 起点入队
    q[tail++] = start;
    visited[start] = 1;
    dist[start] = 0;

    while (head < tail) {
        int cur = q[head++];   // 出队

        // 找到终点，返回距离
        if (cur == end) {
            return dist[cur];
        }

        // 遍历所有邻居
        for (int i = 1; i <= n; i++) {
            if (a[cur][i] == 1 && visited[i] == 0) {
                visited[i] = 1;
                dist[i] = dist[cur] + 1;  // 更新距离
                q[tail++] = i;            // 入队
            }
        }
    }

    return -1;  // 未找到
}
```

### 示例演示

**示例**：节点1到节点4的最短路径

```
图：
   1---2---4
    \     /
     \   /
      \ /
       3

邻接矩阵：
   1 2 3 4
1  0 1 1 0
2  1 0 1 1
3  1 1 0 1
4  0 1 1 0

BFS过程：
初始：q=[1], visited[1]=1, dist[1]=0

第1层：
  cur=1, 遍历邻居2,3
    visited[2]=1, dist[2]=1, q=[1,2,3]
    visited[3]=1, dist[3]=1, q=[1,2,3]

第2层：
  cur=2, 遍历邻居4
    visited[4]=1, dist[4]=2, q=[2,3,4]
    cur==end(4), 返回dist[4]=2

结果：最短路径长度为2
```

### BFS层次遍历示例

```
          1 (dist=0)
         / \
        /   \
   2(dist=1) 3(dist=1)
    |         |
    |         |
   4(dist=2)  4(dist=2)

第一次到达4时的距离就是最短距离：2
```

## 测试用例

### 测试用例1

**输入**：
```
4 1 4
0 1 1 0
1 0 1 1
1 1 0 1
0 1 1 0
```

**输出**：
```
2
```

**路径**：1 → 2 → 4 或 1 → 3 → 4

### 测试用例2

**输入**：
```
3 1 3
0 1 0
1 0 1
0 1 0
```

**输出**：
```
2
```

**路径**：1 → 2 → 3

### 测试用例3

**输入**：
```
3 1 2
0 1 0
1 0 0
0 0 0
```

**输出**：
```
1
```

**路径**：1 → 2（直接连接）

## 常见错误

1. **忘记更新距离**：每次访问新节点时，必须更新`dist[i] = dist[cur] + 1`
2. **队列实现错误**：注意`head`和`tail`指针的使用
3. **访问标记错误**：入队时就应该标记为已访问，不是出队时
4. **边界检查**：注意节点编号从1开始还是从0开始

## 算法复杂度

- **时间复杂度**：O(V + E)，V为节点数，E为边数
- **空间复杂度**：O(V)，用于队列和访问标记

## 扩展思考

1. **如何记录路径**？使用`parent`数组记录每个节点的前驱
2. **如何优化空间**？使用更高效的队列实现
3. **如何支持加权图**？需要使用Dijkstra算法或A*算法

## BFS vs DFS

- **BFS**：层次遍历，第一次到达目标时路径最短
- **DFS**：深度优先，不能保证最短路径，需要遍历所有路径后比较

对于无权图的最短路径问题，BFS是最优选择。

