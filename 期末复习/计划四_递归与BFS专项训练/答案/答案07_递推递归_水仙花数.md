# 答案07：水仙花数（递归）

## 完整代码

见 `答案07_递推递归_水仙花数.cpp`

## 解题思路

### 核心算法

使用递归提取数字的各位数字，并递归计算各位数字的立方和。

### 递归三要素

1. **终止条件**：
   - n == 0：返回0（所有位都已处理完）

2. **递归关系**：
   - 提取个位数字：`digit = n % 10`
   - 计算个位的立方：`digit³`
   - 递归处理剩余部分：`sumOfCubes(n / 10)`
   - 总和 = 个位的立方 + 剩余部分的立方和

3. **递归调用**：调用自身处理去掉个位后的数字

### 关键代码逻辑

```cpp
int sumOfCubes(int n) {
    // 终止条件
    if (n == 0) {
        return 0;
    }
    
    // 递归关系：提取个位数字，计算立方，递归处理剩余部分
    int digit = n % 10;
    return digit * digit * digit + sumOfCubes(n / 10);
}
```

### 示例演示

**示例1**：计算153的各位立方和

```
sumOfCubes(153)
  digit = 3, n/10 = 15
  return 3³ + sumOfCubes(15)
    digit = 5, n/10 = 1
    return 5³ + sumOfCubes(1)
      digit = 1, n/10 = 0
      return 1³ + sumOfCubes(0)
        return 0
      return 1 + 0 = 1
    return 125 + 1 = 126
  return 27 + 126 = 153

结果：153 == 153，是水仙花数
```

**递归调用过程**：
- sumOfCubes(153) → 3³ + sumOfCubes(15)
- sumOfCubes(15) → 5³ + sumOfCubes(1)
- sumOfCubes(1) → 1³ + sumOfCubes(0)
- sumOfCubes(0) → 0
- 返回：27 + 125 + 1 = 153

### 递归树示例（153）

```
        sumOfCubes(153)
            |
      3³ + sumOfCubes(15)
            |
      5³ + sumOfCubes(1)
            |
      1³ + sumOfCubes(0)
            |
            0
```

## 测试用例

### 测试用例1

**输入**：
```
153
```

**输出**：
```
153 is a narcissistic number.
```

### 测试用例2

**输入**：
```
123
```

**输出**：
```
123 is not a narcissistic number.
```

**计算过程**：
- sumOfCubes(123) = 1³ + 2³ + 3³ = 1 + 8 + 27 = 36
- 36 ≠ 123，不是水仙花数

### 测试用例3

**输入**：
```
370
```

**输出**：
```
370 is a narcissistic number.
```

**计算过程**：
- sumOfCubes(370) = 0³ + 7³ + 3³ = 0 + 343 + 27 = 370
- 370 == 370，是水仙花数

## 常见错误

1. **终止条件错误**：应该是`n == 0`，不是`n < 10`
2. **数字提取错误**：注意`n % 10`提取个位，`n / 10`去掉个位
3. **立方计算错误**：应该是`digit * digit * digit`，不是`digit * 3`

## 算法复杂度

- **时间复杂度**：O(log n)，需要处理log₁₀(n)位数字
- **空间复杂度**：O(log n)，递归栈深度为数字的位数

## 扩展思考

1. **如何用迭代实现**？使用循环代替递归
2. **如何支持任意位数**？动态计算位数，使用pow函数
3. **如何优化递归**？使用迭代版本，空间复杂度O(1)

## 对比：递归 vs 迭代

**递归版本**：
```cpp
int sumOfCubes(int n) {
    if (n == 0) return 0;
    int digit = n % 10;
    return digit * digit * digit + sumOfCubes(n / 10);
}
```

**迭代版本**（原题目的实现）：
```cpp
bool narcissistic(int number) {
    int temp = number;
    int sum = 0;
    while(temp > 0) {
        int digit = temp % 10;
        sum += digit * digit * digit;
        temp /= 10;
    }
    return sum == number;
}
```

两者算法思想相同，只是实现方式不同。递归更直观，迭代更节省空间。

