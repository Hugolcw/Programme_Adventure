# 答案05：最大公约数（递归）

## 完整代码

见 `答案05_递推递归_最大公约数.cpp`

## 解题思路

### 核心算法

欧几里得算法可以用递归实现。算法基于原理：gcd(a, b) = gcd(b, a % b)，当b=0时，a就是最大公约数。

### 递归三要素

1. **终止条件**：
   - b == 0：返回a（此时a就是最大公约数）

2. **递归关系**：
   - gcd(a, b) = gcd(b, a % b)

3. **递归调用**：调用自身计算gcd(b, a % b)

### 关键代码逻辑

```cpp
int gcd(int a, int b) {
    // 终止条件：b == 0，a就是最大公约数
    if (b == 0) {
        return a;
    }
    
    // 递归关系：gcd(a, b) = gcd(b, a % b)
    return gcd(b, a % b);
}
```

### 示例演示

**示例1**：gcd(48, 18)

```
gcd(48, 18)
  → gcd(18, 48 % 18) = gcd(18, 12)
    → gcd(12, 18 % 12) = gcd(12, 6)
      → gcd(6, 12 % 6) = gcd(6, 0)
        → b == 0，返回6
```

**递归调用过程**：
- gcd(48, 18) → gcd(18, 12) → gcd(12, 6) → gcd(6, 0) → 返回6

**示例2**：gcd(17, 13)

```
gcd(17, 13)
  → gcd(13, 17 % 13) = gcd(13, 4)
    → gcd(4, 13 % 4) = gcd(4, 1)
      → gcd(1, 4 % 1) = gcd(1, 0)
        → b == 0，返回1
```

### 递归树示例（gcd(48, 18)）

```
        gcd(48, 18)
            |
        gcd(18, 12)
            |
        gcd(12, 6)
            |
        gcd(6, 0)
            |
            6
```

## 测试用例

### 测试用例1

**输入**：
```
48 18
```

**输出**：
```
6
```

### 测试用例2

**输入**：
```
100 25
```

**输出**：
```
25
```

### 测试用例3

**输入**：
```
17 13
```

**输出**：
```
1
```

## 常见错误

1. **终止条件错误**：应该是`b == 0`，不是`a == 0`
2. **递归关系错误**：应该是`gcd(b, a % b)`，注意参数顺序
3. **边界处理**：虽然题目保证输入为正整数，但递归过程中可能出现0

## 算法复杂度

- **时间复杂度**：O(log min(a, b))，每次递归a和b至少减半
- **空间复杂度**：O(log min(a, b))，递归栈深度

## 扩展思考

1. **如何用迭代实现**？使用循环代替递归
2. **如何计算最小公倍数（LCM）**？LCM(a, b) = a × b / gcd(a, b)
3. **如何优化递归**？使用迭代版本，空间复杂度O(1)

## 对比：递归 vs 迭代

**递归版本**：
```cpp
int gcd(int a, int b) {
    if (b == 0) return a;
    return gcd(b, a % b);
}
```

**迭代版本**（原题目的实现）：
```cpp
int gcd(int a, int b) {
    while (b != 0) {
        int temp = a % b;
        a = b;
        b = temp;
    }
    return a;
}
```

两者算法思想相同，只是实现方式不同。递归更直观，迭代更节省空间。

