# 答案10：岛屿数量统计

## 完整代码

见 `答案10_应用BFS_岛屿数量统计.cpp`

## 解题思路

### 核心算法

使用多起点BFS统计连通块（岛屿）的数量。每次找到一个未访问的陆地，就从该陆地开始BFS，标记整个连通块。

### 算法思路

1. **遍历整个网格**：
   - 对每个格子(i, j)，如果`grid[i][j] == 1`且未访问，说明发现新的岛屿

2. **从该陆地开始BFS**：
   - 将该陆地入队
   - BFS标记所有与该陆地连通的陆地
   - 岛屿数量+1

3. **重复**：
   - 继续遍历，寻找下一个未访问的陆地
   - 重复上述过程

### 关键代码逻辑

```cpp
void bfs(int grid[][N], int visited[][N], int n, int m, int startX, int startY) {
    int dx[] = {-1, 1, 0, 0};
    int dy[] = {0, 0, -1, 1};
    
    Point q[N * N];
    int head = 0, tail = 0;
    
    q[tail++] = {startX, startY};
    visited[startX][startY] = 1;
    
    while (head < tail) {
        Point cur = q[head++];
        
        // 遍历四个方向的邻居
        for (int i = 0; i < 4; i++) {
            int nx = cur.x + dx[i];
            int ny = cur.y + dy[i];
            
            // 如果是未访问的陆地，标记并入队
            if (nx >= 0 && nx < n && ny >= 0 && ny < m &&
                grid[nx][ny] == 1 && visited[nx][ny] == 0) {
                visited[nx][ny] = 1;
                q[tail++] = {nx, ny};
            }
        }
    }
}

int main() {
    // ... 读取输入 ...
    
    int count = 0;
    for (int i = 0; i < n; i++) {
        for (int j = 0; j < m; j++) {
            // 找到未访问的陆地
            if (grid[i][j] == 1 && visited[i][j] == 0) {
                bfs(grid, visited, n, m, i, j);  // 标记整个连通块
                count++;  // 岛屿数量+1
            }
        }
    }
    
    cout << count << endl;
}
```

### 示例演示

**示例**：4×5网格

```
网格：
1 1 0 0 0
1 1 0 0 0
0 0 1 0 0
0 0 0 1 1

遍历过程：
1. 找到(0,0)，grid[0][0]=1且未访问
   BFS标记连通块：(0,0), (0,1), (1,0), (1,1)
   count = 1

2. 找到(2,2)，grid[2][2]=1且未访问
   BFS标记连通块：(2,2)
   count = 2

3. 找到(3,3)，grid[3][3]=1且未访问
   BFS标记连通块：(3,3), (3,4)
   count = 3

结果：3个岛屿
```

### BFS标记过程示例

**岛屿1**（左上角）：
```
(0,0) → (0,1)
  ↓
(1,0) → (1,1)
```

**岛屿2**（中间）：
```
(2,2)
```

**岛屿3**（右下角）：
```
(3,3) → (3,4)
```

## 测试用例

### 测试用例1

**输入**：
```
4 5
1 1 0 0 0
1 1 0 0 0
0 0 1 0 0
0 0 0 1 1
```

**输出**：
```
3
```

### 测试用例2

**输入**：
```
3 3
1 1 1
1 0 1
1 1 1
```

**输出**：
```
1
```

**说明**：所有陆地都连通，形成一个岛屿

### 测试用例3

**输入**：
```
3 3
1 0 1
0 1 0
1 0 1
```

**输出**：
```
5
```

**说明**：每个1都是一个独立的岛屿

## 常见错误

1. **忘记标记已访问**：必须在入队时标记，否则会重复访问
2. **边界检查错误**：注意数组索引范围
3. **岛屿计数错误**：应该在每次找到新岛屿时计数，不是每次BFS调用
4. **方向数组错误**：确保上下左右四个方向正确

## 算法复杂度

- **时间复杂度**：O(n × m)，每个格子最多访问一次
- **空间复杂度**：O(n × m)，用于访问标记和队列

## 扩展思考

1. **如何统计岛屿的最大面积**？在BFS过程中计数访问的格子数
2. **如何找到岛屿的边界**？在BFS时检查邻居是否有水域
3. **如何支持8方向连通**？修改方向数组到8个方向
4. **如何用DFS实现**？使用递归DFS代替BFS

## DFS vs BFS

对于连通块统计问题，DFS和BFS都可以：
- **DFS**：递归实现更简洁，但可能栈溢出
- **BFS**：迭代实现更安全，适合大规模数据

## 应用场景

- **图像处理**：统计连通区域
- **地图分析**：统计岛屿、湖泊数量
- **网络分析**：统计连通组件

