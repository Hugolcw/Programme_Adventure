# 答案06：回文数判断（递归）

## 完整代码

见 `答案06_递推递归_回文数判断.cpp`

## 解题思路

### 核心算法

使用递归判断字符串是否为回文。递归比较首尾字符，如果相同，递归判断中间部分。

### 方法1：字符串递归（推荐）

将数字转为字符串，递归比较首尾字符。

### 递归三要素

1. **终止条件**：
   - 字符串长度为0或1：返回true

2. **递归关系**：
   - 如果首尾字符相同：递归判断中间部分（去掉首尾）
   - 如果首尾字符不同：返回false

3. **递归调用**：调用自身判断子字符串

### 关键代码逻辑

```cpp
bool isPalindrome(string s, int left, int right) {
    // 终止条件：左右指针相遇或交叉
    if (left >= right) {
        return true;
    }
    
    // 递归关系：比较首尾字符
    if (s[left] == s[right]) {
        // 首尾相同，递归判断中间部分
        return isPalindrome(s, left + 1, right - 1);
    } else {
        // 首尾不同，不是回文
        return false;
    }
}
```

### 示例演示

**示例1**：判断"121"

```
isPalindrome("121", 0, 2)
  s[0]='1' == s[2]='1' → 递归判断中间部分
  isPalindrome("121", 1, 1)
    left=1 >= right=1 → 返回true
  返回true
```

**示例2**：判断"123"

```
isPalindrome("123", 0, 2)
  s[0]='1' != s[2]='3' → 返回false
```

## 测试用例

### 测试用例1

**输入**：
```
121
```

**输出**：
```
yes
```

### 测试用例2

**输入**：
```
123
```

**输出**：
```
no
```

### 测试用例3

**输入**：
```
1
```

**输出**：
```
yes
```

## 常见错误

1. **终止条件错误**：应该是`left >= right`，不是`left == right`
2. **字符串转换错误**：注意将数字转为字符串的方法
3. **边界处理**：单个数字是回文数

## 算法复杂度

- **时间复杂度**：O(n)，n为数字的位数
- **空间复杂度**：O(n)，递归栈深度为n/2

