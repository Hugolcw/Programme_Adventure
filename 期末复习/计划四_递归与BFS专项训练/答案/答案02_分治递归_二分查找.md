# 答案02：二分查找

## 完整代码

见 `答案02_分治递归_二分查找.cpp`

## 解题思路

### 核心算法

二分查找是典型的分治递归算法。每次将查找区间分成两半，判断目标值在哪一半，然后在对应的一半中递归查找。

### 递归三要素

1. **终止条件**：
   - `left > right`：查找区间为空，未找到，返回-1
   - `a[mid] == target`：找到目标值，返回索引mid

2. **递归关系**：
   - 如果`target < a[mid]`：目标值在左半部分`[left, mid-1]`
   - 如果`target > a[mid]`：目标值在右半部分`[mid+1, right]`

3. **递归调用**：在对应的子区间中递归查找

### 关键代码逻辑

```cpp
int binarySearch(int a[], int left, int right, int target) {
    // 终止条件1：查找区间为空
    if (left > right) {
        return -1;
    }
    
    int mid = left + (right - left) / 2;  // 避免溢出
    
    // 终止条件2：找到目标值
    if (a[mid] == target) {
        return mid;
    }
    
    // 递归关系：在左半部分或右半部分查找
    if (target < a[mid]) {
        return binarySearch(a, left, mid - 1, target);
    } else {
        return binarySearch(a, mid + 1, right, target);
    }
}
```

### 示例演示

**示例**：数组[1, 2, 3, 4, 5]，查找target=3

```
初始：left=0, right=4
mid = (0+4)/2 = 2, a[2]=3 == target → 找到，返回2
```

**示例**：数组[1, 2, 3, 4, 5]，查找target=6

```
第1次：left=0, right=4
mid = 2, a[2]=3 < 6 → 在右半部分[3,4]查找

第2次：left=3, right=4
mid = 3, a[3]=4 < 6 → 在右半部分[4,4]查找

第3次：left=4, right=4
mid = 4, a[4]=5 < 6 → 在右半部分[5,4]查找

第4次：left=5, right=4
left > right → 未找到，返回-1
```

### 递归树示例（查找3）

```
binarySearch([1,2,3,4,5], 0, 4, 3)
  mid=2, a[2]=3 == 3 → 返回2
```

### 递归树示例（查找6）

```
binarySearch([1,2,3,4,5], 0, 4, 6)
  mid=2, a[2]=3 < 6
  └─> binarySearch([1,2,3,4,5], 3, 4, 6)
        mid=3, a[3]=4 < 6
        └─> binarySearch([1,2,3,4,5], 4, 4, 6)
              mid=4, a[4]=5 < 6
              └─> binarySearch([1,2,3,4,5], 5, 4, 6)
                    left=5 > right=4 → 返回-1
```

## 测试用例

### 测试用例1

**输入**：
```
5 3
1 2 3 4 5
```

**输出**：
```
2
```

### 测试用例2

**输入**：
```
5 6
1 2 3 4 5
```

**输出**：
```
-1
```

### 测试用例3

**输入**：
```
1 1
1
```

**输出**：
```
0
```

## 常见错误

1. **边界更新错误**：应该是`mid-1`和`mid+1`，不是`mid`
2. **终止条件错误**：应该是`left > right`，不是`left >= right`
3. **整数溢出**：`(left + right) / 2`可能溢出，应使用`left + (right - left) / 2`
4. **数组未排序**：二分查找要求数组必须有序

## 算法复杂度

- **时间复杂度**：O(log n)，每次将查找区间缩小一半
- **空间复杂度**：O(log n)，递归栈的深度为log n

## 扩展思考

1. **如何实现非递归版本**？使用循环代替递归
2. **如何查找第一个/最后一个等于target的位置**？修改终止条件和边界处理
3. **如何在旋转数组中查找**？需要额外的判断逻辑

