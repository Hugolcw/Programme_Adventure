# 答案09：迷宫最短路径

## 完整代码

见 `答案09_应用BFS_迷宫最短路径.cpp`

## 解题思路

### 核心算法

使用二维BFS算法在迷宫中寻找最短路径。这是BFS的经典应用场景。

### 二维BFS特点

1. **节点是坐标**：使用(x, y)表示位置
2. **方向数组**：定义上下左右四个方向
3. **边界检查**：检查坐标是否在网格范围内
4. **障碍物检查**：检查目标位置是否为可走路径

### 算法步骤

1. **初始化**：
   - 使用结构体或数组存储坐标
   - 定义方向数组：`dx[] = {-1, 1, 0, 0}`, `dy[] = {0, 0, -1, 1}`
   - 距离数组：`dist[x][y]`记录到起点(0,0)的距离

2. **BFS主循环**：
   - 将起点(0,0)入队，距离为0
   - 当队列非空时：
     - 取出队首坐标
     - 如果到达终点(n-1, m-1)，返回距离
     - 遍历四个方向，如果新位置有效且未访问，入队并更新距离

### 关键代码逻辑

```cpp
struct Point {
    int x, y;
};

int bfs(int maze[][N], int n, int m) {
    // 方向数组：上下左右
    int dx[] = {-1, 1, 0, 0};
    int dy[] = {0, 0, -1, 1};
    
    Point q[N * N];              // 队列
    int visited[N][N] = {0};     // 访问标记
    int dist[N][N] = {0};        // 距离数组
    int head = 0, tail = 0;
    
    // 起点入队
    q[tail++] = {0, 0};
    visited[0][0] = 1;
    dist[0][0] = 0;
    
    while (head < tail) {
        Point cur = q[head++];
        
        // 到达终点
        if (cur.x == n - 1 && cur.y == m - 1) {
            return dist[cur.x][cur.y];
        }
        
        // 遍历四个方向
        for (int i = 0; i < 4; i++) {
            int nx = cur.x + dx[i];
            int ny = cur.y + dy[i];
            
            // 检查新位置是否有效
            if (nx >= 0 && nx < n && ny >= 0 && ny < m &&
                maze[nx][ny] == 0 && visited[nx][ny] == 0) {
                visited[nx][ny] = 1;
                dist[nx][ny] = dist[cur.x][cur.y] + 1;
                q[tail++] = {nx, ny};
            }
        }
    }
    
    return -1;  // 无法到达
}
```

### 示例演示

**示例**：5×5迷宫

```
迷宫：
0 0 0 0 0
0 1 1 1 0
0 0 0 0 0
0 1 1 1 0
0 0 0 0 0

BFS过程（部分）：
第0层：(0,0) dist=0
第1层：(0,1) dist=1, (1,0) dist=1
第2层：(0,2) dist=2, (2,0) dist=2
...
第8层：(4,4) dist=8 到达终点

最短路径：8步
```

### BFS搜索过程示例

```
起点(0,0) - dist=0
    |
第1层：(0,1) dist=1, (1,0) dist=1
    |
第2层：(0,2) dist=2, (2,0) dist=2
    |
...
第8层：(4,4) dist=8 终点
```

## 测试用例

### 测试用例1

**输入**：
```
5 5
0 0 0 0 0
0 1 1 1 0
0 0 0 0 0
0 1 1 1 0
0 0 0 0 0
```

**输出**：
```
8
```

### 测试用例2

**输入**：
```
3 3
0 0 0
0 0 0
0 0 0
```

**输出**：
```
4
```

**最短路径**：(0,0) → (0,1) → (0,2) → (1,2) → (2,2)

### 测试用例3

**输入**：
```
3 3
0 1 0
0 1 0
0 0 0
```

**输出**：
```
4
```

**最短路径**：(0,0) → (1,0) → (2,0) → (2,1) → (2,2)

## 常见错误

1. **边界检查错误**：注意数组索引从0开始，范围是[0, n-1]
2. **方向数组错误**：确保dx和dy对应正确（上下左右）
3. **障碍物检查错误**：应该是`maze[nx][ny] == 0`（可走），不是`== 1`
4. **坐标结构体错误**：确保正确使用结构体存储坐标

## 算法复杂度

- **时间复杂度**：O(n × m)，最坏情况需要访问所有格子
- **空间复杂度**：O(n × m)，用于队列和访问标记

## 扩展思考

1. **如何记录路径**？使用`parent`数组记录每个格子的前驱坐标
2. **如何支持8方向移动**？扩展方向数组到8个方向
3. **如何优化空间**？可以使用更紧凑的数据结构
4. **如何支持加权路径**？需要修改为Dijkstra算法

## 应用场景

- **游戏AI**：寻找最短路径
- **机器人导航**：避开障碍物
- **网络路由**：寻找最短路径

