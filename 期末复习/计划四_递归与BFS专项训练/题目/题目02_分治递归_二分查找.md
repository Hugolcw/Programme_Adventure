# 题目02：二分查找

## 题目类型
分治递归

## 难度
中等

## 知识点
递归、分治思想、二分查找、边界处理

## 题目描述

给定一个升序排列的整数数组和一个目标值，使用递归的二分查找算法查找目标值在数组中的位置（索引从0开始）。如果找到，返回其索引；如果未找到，返回-1。

## 输入格式

第一行输入两个整数n和target（1 <= n <= 1000, -10^9 <= target <= 10^9），分别表示数组长度和目标值。

第二行输入n个升序排列的整数，用空格分隔。

## 输出格式

输出一个整数，表示目标值在数组中的索引（如果找到），或-1（如果未找到）。

## 样例输入1

```
5 3
1 2 3 4 5
```

## 样例输出1

```
2
```

## 样例输入2

```
5 6
1 2 3 4 5
```

## 样例输出2

```
-1
```

## 样例输入3

```
1 1
1
```

## 样例输出3

```
0
```

## 提示

1. **分治思想**：
   - 将查找区间分成两半
   - 判断目标值在左半部分还是右半部分
   - 递归在对应的一半中查找

2. **递归三要素**：
   - **终止条件**：
     - 如果`left > right`，说明未找到，返回-1
     - 如果`a[mid] == target`，说明找到，返回mid
   - **递归关系**：
     - 如果`target < a[mid]`，在左半部分递归查找：`[left, mid-1]`
     - 如果`target > a[mid]`，在右半部分递归查找：`[mid+1, right]`
   - **递归调用**：调用自身在子区间中查找

3. **函数定义**：
   ```cpp
   int binarySearch(int a[], int left, int right, int target) {
       // 终止条件
       if (left > right) return -1;
       
       int mid = (left + right) / 2;
       if (a[mid] == target) return mid;
       
       // 递归关系
       if (target < a[mid]) {
           return binarySearch(a, left, mid-1, target);
       } else {
           return binarySearch(a, mid+1, right, target);
       }
   }
   ```

4. **注意事项**：
   - 数组必须是有序的
   - 注意边界处理：`left`和`right`的更新
   - 注意整数溢出：`mid = (left + right) / 2` 可能溢出，可以用 `mid = left + (right - left) / 2`

## 要求

1. 必须使用递归实现
2. 注意边界情况的处理
3. 代码逻辑清晰，注释适当

---

## 考查重点

- **分治思想**：理解如何将问题分成两半
- **递归边界处理**：正确处理查找区间的边界
- **递归思维**：将查找问题分解为子问题

