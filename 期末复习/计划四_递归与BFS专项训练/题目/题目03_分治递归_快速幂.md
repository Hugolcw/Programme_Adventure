# 题目03：快速幂

## 题目类型
分治递归

## 难度
中等

## 知识点
递归、分治思想、快速幂、模运算

## 题目描述

计算a的n次幂（a^n），其中a和n都是正整数。由于结果可能很大，要求结果对1000000007取模。

请使用递归的快速幂算法实现。

## 输入格式

输入两个正整数a和n（1 <= a <= 10^9, 0 <= n <= 10^9），分别表示底数和指数。

## 输出格式

输出一个整数，表示a^n mod 1000000007的结果。

## 样例输入1

```
2 10
```

## 样例输出1

```
1024
```

## 样例输入2

```
3 5
```

## 样例输出2

```
243
```

## 样例输入3

```
1000000000 1000000000
```

## 样例输出3

```
(结果对1000000007取模)
```

## 提示

1. **快速幂思想**：
   - 如果n是偶数：a^n = (a^(n/2))^2
   - 如果n是奇数：a^n = a × a^(n-1) = a × (a^((n-1)/2))^2
   - 这样可以将时间复杂度从O(n)降低到O(log n)

2. **递归三要素**：
   - **终止条件**：n == 0，返回1（任何数的0次幂都是1）
   - **递归关系**：
     - 如果n是偶数：`power(a, n) = power(a, n/2)²`
     - 如果n是奇数：`power(a, n) = a × power(a, n-1)`
   - **递归调用**：调用自身计算较小的幂

3. **模运算性质**：
   - (a × b) mod m = ((a mod m) × (b mod m)) mod m
   - 在计算过程中每一步都要取模

4. **函数定义**：
   ```cpp
   long long power(long long a, long long n, long long mod) {
       // 终止条件
       if (n == 0) return 1;
       
       // 递归关系
       long long half = power(a, n / 2, mod);
       if (n % 2 == 0) {
           return (half * half) % mod;
       } else {
           return (a * half * half) % mod;
       }
   }
   ```

## 要求

1. 必须使用递归实现
2. 注意模运算，防止溢出
3. 代码逻辑清晰，注释适当

---

## 考查重点

- **分治思想**：理解如何将指数分成两半
- **递归优化**：理解快速幂的递归实现
- **模运算**：理解模运算的性质和应用

