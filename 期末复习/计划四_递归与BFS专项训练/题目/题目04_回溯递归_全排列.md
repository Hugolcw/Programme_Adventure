# 题目04：全排列

## 题目类型
回溯递归

## 难度
较难

## 知识点
递归、回溯思想、状态恢复、排列生成

## 题目描述

给定一个正整数n，生成1到n的所有全排列，并按照字典序输出。

例如，n=3时，所有排列为：
1 2 3
1 3 2
2 1 3
2 3 1
3 1 2
3 2 1

## 输入格式

输入一个正整数n（1 <= n <= 8）。

## 输出格式

输出所有排列，每个排列占一行，数字之间用空格分隔。

## 样例输入1

```
3
```

## 样例输出1

```
1 2 3
1 3 2
2 1 3
2 3 1
3 1 2
3 2 1
```

## 样例输入2

```
2
```

## 样例输出2

```
1 2
2 1
```

## 提示

1. **回溯思想**：
   - 尝试在每个位置放置不同的数字
   - 如果当前放置的数字已经被使用过，跳过
   - 放置完成后，递归处理下一个位置
   - 回溯时恢复状态（标记数字为未使用）

2. **递归三要素**：
   - **终止条件**：已经放置了n个数字，输出当前排列
   - **递归关系**：对于当前位置，尝试放置所有未使用的数字
   - **递归调用**：放置一个数字后，递归处理下一个位置

3. **实现步骤**：
   - 使用数组`arr`存储当前排列
   - 使用数组`used`标记数字是否已使用
   - 递归函数：`permute(arr, used, pos, n)`
     - `pos`：当前要放置的位置（从0开始）
     - 如果`pos == n`，输出排列并返回
     - 否则，尝试放置所有未使用的数字

4. **状态恢复**：
   - 放置数字后，标记为已使用：`used[i] = true`
   - 递归返回后，标记为未使用：`used[i] = false`（回溯）

## 要求

1. 必须使用递归实现
2. 注意状态恢复（回溯的关键）
3. 输出按照字典序（自然顺序即可，因为按顺序尝试）
4. 代码逻辑清晰，注释适当

---

## 考查重点

- **回溯思想**：理解尝试-回溯的过程
- **状态恢复**：理解回溯时需要恢复状态
- **递归生成**：理解如何递归生成所有可能

