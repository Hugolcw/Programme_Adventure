# 题目06：空瓶换水

## 题目类型
复杂逻辑处理

## 难度
中等偏难

## 知识点
递推逻辑、循环控制、边界处理

## 题目描述

小明有n个空瓶子，每m个空瓶子可以换1瓶新水。喝完新水后又会得到空瓶子，可以继续换。此外，如果最后剩下的空瓶子数量刚好是m-1个，可以"赊"1瓶，喝完后再还回1个空瓶子，这样还能多喝1瓶。

计算小明最多能喝多少瓶水。

例如：
- n=15, m=4：可以喝19瓶（常规18瓶 + 赊1瓶）
- n=10, m=3：可以喝14瓶（常规14瓶，不能赊）

## 输入格式

输入两个正整数n和m（1 <= n, m <= 1000），分别表示初始空瓶子数和换1瓶所需的空瓶子数。

## 输出格式

输出一个整数，表示最多能喝多少瓶水。

## 样例输入1

```
15 4
```

## 样例输出1

```
19
```

## 样例输入2

```
10 3
```

## 样例输出2

```
14
```

## 样例输入3

```
20 5
```

## 样例输出3

```
24
```

## 提示

1. **算法思路**：
   - 初始能喝n瓶（直接用空瓶换）
   - 循环：只要有m个空瓶，就换1瓶新水
   - 循环结束后，检查是否可以"赊"1瓶

2. **实现步骤**：
   - 初始化：`total_drank = n`，`empty_bottles = n`
   - 循环：当`empty_bottles >= m`时
     - 计算能换的新瓶数：`new_bottles = empty_bottles / m`
     - 更新总喝数：`total_drank += new_bottles`
     - 更新空瓶数：`empty_bottles = empty_bottles % m + new_bottles`
   - 检查"赊"的条件：如果`empty_bottles == m - 1`，则`total_drank++`

3. **"赊"的逻辑**：
   - 如果最后剩下m-1个空瓶，可以"赊"1瓶
   - 喝完"赊"的1瓶后，得到1个空瓶，加上原来的m-1个，正好是m个
   - 用这m个空瓶还"赊"的1瓶，所以净多喝1瓶

## 要求

1. 注意处理"赊"的边界情况
2. 代码逻辑清晰，注释适当

---

## 考查重点

- **递推逻辑**：理解多轮换瓶的过程
- **边界处理**：理解"赊"1瓶的特殊逻辑
- **循环控制**：正确处理循环终止条件

