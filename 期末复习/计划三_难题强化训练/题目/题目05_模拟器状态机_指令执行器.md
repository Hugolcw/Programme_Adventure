# 题目05：指令执行器

## 题目类型
模拟器/状态机

## 难度
中等偏难

## 知识点
指令解析、状态管理、循环控制、栈的应用

## 题目描述

实现一个简单的指令执行器，能够执行一组简化的指令序列。指令集包含以下5种指令：

- `A`：将累加器加1
- `S`：将累加器减1
- `P`：输出累加器的值（输出后换行）
- `[`：如果累加器为0，跳转到匹配的`]`
- `]`：如果累加器不为0，跳转回匹配的`[`

**注意**：累加器初始值为0，可以存储任意整数（包括负数）。

## 输入格式

输入一行，包含一个指令序列，长度不超过1000。指令序列只包含字符：`A`、`S`、`P`、`[`、`]`。

## 输出格式

根据指令执行结果输出相应的数字，每个数字占一行。

## 样例输入1

```
AAAAP
```

## 样例输出1

```
4
```

## 样例输入2

```
AAAPAAAP
```

## 样例输出2

```
3
5
```

## 样例输入3

```
[A]P
```

## 样例输出3

```
0
```

**解释**：`[`检查累加器为0，直接跳转到`]`，不执行`A`，所以输出0。

## 样例输入4

```
AA[SA]P
```

## 样例输出4

```
2
```

**解释**：
- 初始：acc=0
- `AA`：acc=2
- `[`：acc=2≠0，进入循环
- `SA`：acc=2-1+1=2（循环一次）
- `]`：acc=2≠0，跳回`[`
- `SA`：acc=2-1+1=2（循环第二次）
- `]`：acc=2≠0，跳回`[`
- ...（无限循环，但题目保证不会无限循环）

**注意**：实际测试用例会保证程序能够终止。

## 提示

1. **算法思路**：
   - 使用栈匹配`[`和`]`
   - 使用跳转表记录匹配关系
   - 顺序执行指令，遇到跳转指令时修改程序计数器

2. **实现步骤**：
   - 第一步：预处理，建立`[`和`]`的匹配关系（使用栈）
   - 第二步：执行指令，维护累加器和程序计数器

3. **栈匹配括号**：
   ```cpp
   stack<int> s;
   for (int i = 0; i < len; i++) {
       if (code[i] == '[') {
           s.push(i);
       } else if (code[i] == ']') {
           int start = s.top();
           s.pop();
           jump_map[start] = i;  // [ 的位置 -> ] 的位置
           jump_map[i] = start;  // ] 的位置 -> [ 的位置
       }
   }
   ```

4. **指令执行**：
   - `A`：`acc++`
   - `S`：`acc--`
   - `P`：`cout << acc << endl;`
   - `[`：如果`acc == 0`，`pc = jump_map[pc]`
   - `]`：如果`acc != 0`，`pc = jump_map[pc]`

## 要求

1. 不能使用STL容器（如stack），需要用数组模拟栈
2. 注意处理循环的跳转逻辑
3. 代码逻辑清晰，注释适当

---

## 考查重点

- **指令解析**：如何解析和执行指令序列
- **状态管理**：如何维护累加器和程序计数器
- **循环控制**：如何使用跳转表实现循环

