# 答案04：简单计算器

## 完整代码

见 `答案04_模拟器状态机_简单计算器.cpp`

## 解题思路

### 核心算法

由于只有加法和乘法，且乘法优先级高于加法，可以采用"先乘后加"的策略：
1. 先处理所有乘法运算
2. 再处理所有加法运算

### 算法步骤

1. **解析表达式**：
   - 遍历表达式字符串
   - 提取所有数字和运算符
   - 忽略空格

2. **处理乘法**：
   - 遍历数字和运算符数组
   - 遇到乘法运算符时，将前一个数字和后一个数字相乘
   - 用结果替换这两个数字和中间的运算符
   - 重复直到没有乘法运算符

3. **处理加法**：
   - 将所有剩余数字相加

### 关键代码逻辑

```cpp
// 1. 解析表达式，提取数字和运算符
int nums[1005];
char ops[1005];
int numCount = 0, opCount = 0;

int i = 0;
while (i < s.length()) {
    // 跳过空格
    if (s[i] == ' ') {
        i++;
        continue;
    }
    
    // 提取数字
    if (s[i] >= '0' && s[i] <= '9') {
        int num = 0;
        while (i < s.length() && s[i] >= '0' && s[i] <= '9') {
            num = num * 10 + (s[i] - '0');
            i++;
        }
        nums[numCount++] = num;
    }
    // 提取运算符
    else if (s[i] == '+' || s[i] == '*') {
        ops[opCount++] = s[i];
        i++;
    }
}

// 2. 先处理所有乘法
int newNums[1005];
char newOps[1005];
int newNumCount = 0, newOpCount = 0;

newNums[0] = nums[0];
for (int i = 0; i < opCount; i++) {
    if (ops[i] == '*') {
        // 乘法：将最后一个数字与下一个数字相乘
        newNums[newNumCount - 1] *= nums[i + 1];
    } else {
        // 加法：保留数字和运算符
        newNums[newNumCount++] = nums[i + 1];
        newOps[newOpCount++] = ops[i];
    }
}

// 3. 处理所有加法
int result = newNums[0];
for (int i = 0; i < newOpCount; i++) {
    result += newNums[i + 1];
}
```

### 示例演示

**示例1**：`2+3*4`

1. 解析：nums=[2,3,4], ops=['+','*']
2. 处理乘法：
   - 遇到'*'：3*4=12
   - newNums=[2,12], newOps=['+']
3. 处理加法：2+12=14

**示例2**：`2*3+4*5`

1. 解析：nums=[2,3,4,5], ops=['*','+','*']
2. 处理乘法：
   - 遇到'*'：2*3=6
   - 遇到'*'：4*5=20
   - newNums=[6,20], newOps=['+']
3. 处理加法：6+20=26

## 测试用例

### 测试用例1

**输入**：
```
2+3*4
```

**输出**：
```
14
```

### 测试用例2

**输入**：
```
1+2+3*4
```

**输出**：
```
15
```

### 测试用例3

**输入**：
```
2*3+4*5
```

**输出**：
```
26
```

### 测试用例4

**输入**：
```
1 + 2 * 3 + 4
```

**输出**：
```
11
```

## 常见错误

1. **数字提取不完整**：需要循环读取连续的数字字符
2. **空格处理错误**：需要忽略空格
3. **乘法处理顺序错误**：应该先处理所有乘法，再处理加法
4. **数组索引错误**：注意数字和运算符的对应关系

## 算法复杂度

- **时间复杂度**：O(n)，n为表达式长度
- **空间复杂度**：O(n)，用于存储数字和运算符

## 扩展思考

1. **如何支持减法**？将减法转换为加法（加负数）
2. **如何支持括号**？需要使用递归或栈来处理括号
3. **如何支持除法**？类似乘法，但需要注意除零错误

