# 答案07：相等数

## 完整代码

见 `答案07_复杂逻辑处理_相等数.cpp`

## 解题思路

### 核心算法

对于每个数字d（1-9），生成所有由d组成的相等数，检查是否在区间[a, b]内。

### 算法步骤

1. **遍历数字1到9**：
   - 对每个数字d，生成所有由d组成的相等数

2. **生成相等数**：
   - 初始：`num = d`（1位数）
   - 循环：`num = num * 10 + d`，生成2位数、3位数、...
   - 直到`num > b`时停止

3. **检查并输出**：
   - 如果`num >= a && num <= b`，输出该数
   - 使用标志变量记录是否找到相等数

### 关键代码逻辑

```cpp
bool found = false;

for (int d = 1; d <= 9; d++) {
    long long num = d;  // 从1位数开始
    
    while (num <= b) {
        if (num >= a) {
            if (found) cout << " ";  // 不是第一个，输出空格
            cout << num;
            found = true;
        }
        
        num = num * 10 + d;  // 生成下一个相等数
    }
}

if (!found) {
    cout << "none";
}
cout << endl;
```

### 示例演示

**示例1**：a=1, b=50

```
d=1: num=1(在区间), 11(在区间), 111(超出) -> 输出1 11
d=2: num=2(在区间), 22(在区间), 222(超出) -> 输出2 22
d=3: num=3(在区间), 33(在区间), 333(超出) -> 输出3 33
d=4: num=4(在区间), 44(在区间), 444(超出) -> 输出4 44
d=5: num=5(在区间), 55(超出) -> 输出5
d=6: num=6(在区间), 66(超出) -> 输出6
d=7: num=7(在区间), 77(超出) -> 输出7
d=8: num=8(在区间), 88(超出) -> 输出8
d=9: num=9(在区间), 99(超出) -> 输出9

最终输出：1 2 3 4 5 6 7 8 9 11 22 33 44
```

**示例2**：a=100, b=200

```
d=1: num=1, 11, 111(在区间), 1111(超出) -> 输出111
d=2-9: 所有相等数都超出200

最终输出：111
```

## 测试用例

### 测试用例1

**输入**：
```
1 50
```

**输出**：
```
1 2 3 4 5 6 7 8 9 11 22 33 44
```

### 测试用例2

**输入**：
```
100 200
```

**输出**：
```
111
```

### 测试用例3

**输入**：
```
1000 2000
```

**输出**：
```
1111
```

## 常见错误

1. **数据类型错误**：需要使用`long long`，因为可能超过int范围
2. **输出格式错误**：注意空格的处理，第一个数前不加空格
3. **循环条件错误**：应该是`num <= b`，不是`num < b`
4. **数字生成错误**：注意公式`num = num * 10 + d`

## 算法复杂度

- **时间复杂度**：O(9 × log b)，每个数字最多生成log₁₀(b)个相等数
- **空间复杂度**：O(1)

## 扩展思考

1. **如何优化输出顺序**？可以先收集所有相等数，排序后输出
2. **如何统计相等数的个数**？在生成过程中计数
3. **如何支持更大的范围**？使用字符串处理大数

