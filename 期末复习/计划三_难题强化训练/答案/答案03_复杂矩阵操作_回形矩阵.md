# 答案03：回形矩阵

## 完整代码

见 `答案03_复杂矩阵操作_回形矩阵.cpp`

## 解题思路

### 核心算法

回形矩阵实际上就是螺旋矩阵，填充方式完全相同。可以使用与螺旋矩阵相同的方向数组方法，也可以使用按层填充的方法。

### 方法一：方向数组法（推荐）

与螺旋矩阵完全相同，使用方向数组控制移动方向。

### 方法二：按层填充法

按照从外到内的顺序，逐层填充矩阵。

#### 算法步骤

1. **计算层数**：
   - 总层数：`layers = (n + 1) / 2`
   - 例如：n=4时，layers=2；n=5时，layers=3

2. **对每一层填充**：
   - 层k的范围：从(k,k)到(n-1-k, n-1-k)
   - 填充顺序：上边（从左到右）→ 右边（从上到下）→ 下边（从右到左）→ 左边（从下到上）

3. **边界处理**：
   - 内层可能不完整（奇数n时中心只有一个元素）
   - 需要判断是否已经填充完所有数字

### 关键代码逻辑（按层填充）

```cpp
int num = 1;
int layers = (n + 1) / 2;

for (int layer = 0; layer < layers && num <= n * n; layer++) {
    int start = layer;
    int end = n - 1 - layer;
    
    // 上边：从左到右
    for (int j = start; j <= end && num <= n * n; j++) {
        matrix[start][j] = num++;
    }
    
    // 右边：从上到下（跳过右上角）
    for (int i = start + 1; i <= end && num <= n * n; i++) {
        matrix[i][end] = num++;
    }
    
    // 下边：从右到左（跳过右下角）
    for (int j = end - 1; j >= start && num <= n * n; j--) {
        matrix[end][j] = num++;
    }
    
    // 左边：从下到上（跳过左下角和左上角）
    for (int i = end - 1; i > start && num <= n * n; i--) {
        matrix[i][start] = num++;
    }
}
```

### 示例演示（按层填充，n=4）

**第0层（外层）**：
- 上边：(0,0)到(0,3)：1, 2, 3, 4
- 右边：(1,3)到(3,3)：5, 6
- 下边：(3,2)到(3,0)：7, 8, 9, 10
- 左边：(2,0)到(1,0)：11

**第1层（内层）**：
- 上边：(1,1)到(1,2)：12, 13, 14
- 右边：(2,2)到(2,2)：15
- 下边：(2,1)到(2,1)：16（已填充，跳过）

**最终矩阵**：
```
1  2  3  4
12 13 14 5
11 16 15 6
10 9  8  7
```

## 测试用例

### 测试用例1

**输入**：
```
4
```

**输出**：
```
   1   2   3   4
  12  13  14   5
  11  16  15   6
  10   9   8   7
```

### 测试用例2

**输入**：
```
5
```

**输出**：
```
   1   2   3   4   5
  16  17  18  19   6
  15  24  25  20   7
  14  23  22  21   8
  13  12  11  10   9
```

## 常见错误

1. **层数计算错误**：注意使用`(n + 1) / 2`而不是`n / 2`
2. **边界重复填充**：注意四个边的起始和结束位置，避免重复
3. **内层处理错误**：奇数n时中心只有一个元素，需要特殊处理
4. **输出格式错误**：注意使用`setw(4)`实现右对齐

## 算法复杂度

- **时间复杂度**：O(n²)，需要填充n²个位置
- **空间复杂度**：O(n²)，用于存储矩阵

## 扩展思考

1. **回形矩阵和螺旋矩阵的关系**：本质相同，只是描述角度不同
2. **如何实现逆时针回形**？改变填充顺序
3. **如何实现矩形回形矩阵**？处理n×m的矩形矩阵

