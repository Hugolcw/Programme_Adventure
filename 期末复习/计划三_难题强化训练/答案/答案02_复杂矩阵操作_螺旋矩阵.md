# 答案02：螺旋矩阵

## 完整代码

见 `答案02_复杂矩阵操作_螺旋矩阵.cpp`

## 解题思路

### 核心算法

按照顺时针方向（右→下→左→上）螺旋填充矩阵，使用方向数组控制移动方向，遇到边界或已填充位置时改变方向。

### 算法步骤

1. **初始化**：
   - 创建n×n的矩阵，初始化为0
   - 定义方向数组：右(0,1)、下(1,0)、左(0,-1)、上(-1,0)
   - 从位置(0,0)开始，初始方向为右（dir=0）

2. **填充过程**：
   - 填充当前位置为当前数字（从1开始）
   - 计算下一个位置：`nx = x + dx[dir]`, `ny = y + dy[dir]`
   - 检查下一个位置是否有效：
     - 在矩阵范围内：`0 <= nx < n && 0 <= ny < n`
     - 未被填充：`matrix[nx][ny] == 0`
   - 如果有效，移动到下一个位置
   - 如果无效，改变方向：`dir = (dir + 1) % 4`，然后重新计算下一个位置

3. **重复**：直到填充完n²个数字

### 关键代码逻辑

```cpp
// 方向数组：右、下、左、上
int dx[] = {0, 1, 0, -1};
int dy[] = {1, 0, -1, 0};

int x = 0, y = 0;  // 当前位置
int dir = 0;       // 当前方向（0=右）

for (int num = 1; num <= n * n; num++) {
    matrix[x][y] = num;
    
    // 计算下一个位置
    int nx = x + dx[dir];
    int ny = y + dy[dir];
    
    // 检查下一个位置是否有效
    if (nx < 0 || nx >= n || ny < 0 || ny >= n || matrix[nx][ny] != 0) {
        // 改变方向
        dir = (dir + 1) % 4;
        nx = x + dx[dir];
        ny = y + dy[dir];
    }
    
    x = nx;
    y = ny;
}
```

### 示例演示

**n=3时的填充过程**：

```
初始：dir=0(右), x=0, y=0
1: (0,0)=1, 下一个(0,1)有效，移动
2: (0,1)=2, 下一个(0,2)有效，移动
3: (0,2)=3, 下一个(0,3)无效(越界)，改变方向dir=1(下)
4: (1,2)=4, 下一个(2,2)有效，移动
5: (2,2)=5, 下一个(2,3)无效(越界)，改变方向dir=2(左)
6: (2,1)=6, 下一个(2,0)有效，移动
7: (2,0)=7, 下一个(3,0)无效(越界)，改变方向dir=3(上)
8: (1,0)=8, 下一个(0,0)无效(已填充)，改变方向dir=0(右)
9: (1,1)=9, 完成

最终矩阵：
1 2 3
8 9 4
7 6 5
```

## 测试用例

### 测试用例1

**输入**：
```
3
```

**输出**：
```
   1   2   3
   8   9   4
   7   6   5
```

### 测试用例2

**输入**：
```
4
```

**输出**：
```
   1   2   3   4
  12  13  14   5
  11  16  15   6
  10   9   8   7
```

### 测试用例3

**输入**：
```
1
```

**输出**：
```
   1
```

## 常见错误

1. **方向数组定义错误**：注意dx和dy的对应关系
2. **边界检查不完整**：需要同时检查越界和已填充
3. **输出格式错误**：注意使用`setw(4)`实现右对齐
4. **方向切换逻辑错误**：应该在检测到无效位置后再切换方向

## 算法复杂度

- **时间复杂度**：O(n²)，需要填充n²个位置
- **空间复杂度**：O(n²)，用于存储矩阵

## 扩展思考

1. **如何实现逆时针螺旋**？改变方向数组的顺序
2. **如何从中心开始螺旋**？从(n/2, n/2)开始
3. **如何实现矩形螺旋矩阵**？处理n×m的矩形矩阵

