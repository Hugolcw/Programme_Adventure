# 答案05：指令执行器

## 完整代码

见 `答案05_模拟器状态机_指令执行器.cpp`

## 解题思路

### 核心算法

这是一个简化版的"机器时代"，核心思想相同：
1. 预处理：使用栈匹配`[`和`]`，建立跳转表
2. 执行：顺序执行指令，遇到跳转指令时修改程序计数器

### 算法步骤

1. **预处理阶段**（建立跳转表）：
   - 使用栈（数组模拟）匹配`[`和`]`
   - 建立跳转映射：`jump_map[i]`表示位置i匹配的位置

2. **执行阶段**：
   - 维护累加器`acc`和程序计数器`pc`
   - 根据当前指令执行相应操作
   - 遇到跳转指令时，根据条件修改`pc`

### 关键代码逻辑

```cpp
// 1. 预处理：建立跳转表
int stack[1005];
int top = 0;
int jump_map[1005] = {0};

for (int i = 0; i < len; i++) {
    if (code[i] == '[') {
        stack[top++] = i;
    } else if (code[i] == ']') {
        int start = stack[--top];
        jump_map[start] = i;  // [ -> ]
        jump_map[i] = start;  // ] -> [
    }
}

// 2. 执行指令
int acc = 0;  // 累加器
int pc = 0;   // 程序计数器

while (pc < len) {
    char op = code[pc];
    
    switch (op) {
        case 'A':
            acc++;
            break;
        case 'S':
            acc--;
            break;
        case 'P':
            cout << acc << endl;
            break;
        case '[':
            if (acc == 0) {
                pc = jump_map[pc];  // 跳转到匹配的]
            }
            break;
        case ']':
            if (acc != 0) {
                pc = jump_map[pc];  // 跳转回匹配的[
            }
            break;
    }
    pc++;
}
```

### 示例演示

**示例1**：`AAAAP`

```
pc=0: A -> acc=1
pc=1: A -> acc=2
pc=2: A -> acc=3
pc=3: A -> acc=4
pc=4: P -> 输出4
结束
```

**示例2**：`[A]P`

```
预处理：jump_map[0]=2, jump_map[2]=0

pc=0: [ -> acc=0，跳转到pc=2
pc=2: ] -> acc=0，不跳转
pc=3: P -> 输出0
结束
```

**示例3**：`AA[SA]P`

```
预处理：jump_map[2]=5, jump_map[5]=2

pc=0: A -> acc=1
pc=1: A -> acc=2
pc=2: [ -> acc=2≠0，进入循环
pc=3: S -> acc=1
pc=4: A -> acc=2
pc=5: ] -> acc=2≠0，跳回pc=2
pc=2: [ -> acc=2≠0，继续循环
...（如果无限循环，题目会保证终止）
```

## 测试用例

### 测试用例1

**输入**：
```
AAAAP
```

**输出**：
```
4
```

### 测试用例2

**输入**：
```
AAAPAAAP
```

**输出**：
```
3
5
```

### 测试用例3

**输入**：
```
[A]P
```

**输出**：
```
0
```

## 常见错误

1. **跳转表建立错误**：注意`[`和`]`的对应关系
2. **程序计数器更新错误**：注意`pc++`的位置，跳转后不应该再`pc++`
3. **循环条件判断错误**：`[`检查`acc==0`，`]`检查`acc!=0`
4. **栈模拟错误**：注意数组模拟栈的`top`指针操作

## 算法复杂度

- **时间复杂度**：O(n + m)，n为指令长度，m为执行指令数（可能很大）
- **空间复杂度**：O(n)，用于存储跳转表和栈

## 扩展思考

1. **如何支持嵌套循环**？栈可以自然处理嵌套
2. **如何优化执行效率**？可以预处理一些简单的指令序列
3. **如何支持更多指令**？扩展switch语句即可

